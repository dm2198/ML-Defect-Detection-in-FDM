# -*- coding: utf-8 -*-
"""vizualization.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/147RaFMD-3PHGza2uJPFk_ZVXdt4YcahR
"""

import tensorflow as tf
import matplotlib.pyplot as plt
import cv2
import os
import numpy as np 
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.preprocessing import image
from tensorflow.keras.optimizers import RMSprop

model = tf.keras.models.Sequential([tf.keras.layers.Conv2D(16,(3,3),activation='relu',input_shape=(200,200,3)),
                                    tf.keras.layers.MaxPool2D(2,2),
                                    #
                                    tf.keras.layers.Conv2D(32,(3,3),activation='relu'),
                                    tf.keras.layers.MaxPool2D(2,2),
                                    #
                                    tf.keras.layers.Conv2D(64,(3,3),activation='relu'),
                                    tf.keras.layers.MaxPool2D(2,2),
                                    ##
                                    tf.keras.layers.Flatten(),
                                    ##
                                    tf.keras.layers.Dense(512,activation='relu'),
                                    tf.keras.layers.Dense(1,activation='sigmoid'
                                    )])

model.summary()

img = image.load_img("/content/drive/MyDrive/basedata/train/defective/cube2_1.jpg",target_size=(200,200))

img

from keras.models import Model
layer_output = [layer.output for layer in model.layers[1:]]

vizualization = tf.keras.models.Model(inputs = model.input, outputs = layer_output)

img = image.load_img("/content/drive/MyDrive/basedata/train/defective/cube2_1.jpg",target_size=(200,200))

from keras_preprocessing.image.utils import img_to_array
x = img_to_array(img)
x.shape

x = x.reshape((1,200,200,3))

x.shape

x= x/255

feature_maps = vizualization.predict(x)

len(feature_maps)

# Commented out IPython magic to ensure Python compatibility.
layer_names = [layer.name for layer in model.layers]
layer_names
# %matplotlib inline

for layer_names, feature_maps in zip(layer_names,feature_maps):
  print(feature_maps.shape)
  if len(feature_maps.shape)==4:
    size = feature_maps.shape[1]
    display_grid  = np.zeros((size,size*channels))
    for i in range(channels):
     x = feature_maps[0,:,:,i]
     x -= x.mean()
     x/=x.std()
     x *=100
     x +=200
     x = np.clip(x,0,255).astype('uint8')
     display_grid[:,i*size:(i+1)*size] = x 
    
    scale = 20./channels
    plt.figure(figsize = (scale*channels, scale))
    plt.title(layer_names)
    plt.imshow(display_grid,aspect = 'auto',cmap = 'viridis')

scale